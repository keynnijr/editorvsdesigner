<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Designer vs Editor ‚Äî Mobile 9:16 (v3)</title>
  <style>
    /* --- MENU PRINCIPAL --- */
    #menuBackdrop {
      position: fixed; inset: 0;
      display: flex; align-items: center; justify-content: center;
      background: rgba(0,0,0,.65); z-index: 9999;
    }
    #menuPanel {
      background: #f7d0a4; color: #2b2a27;
      width: min(520px, 86vw);
      border: 4px solid #4b3a2a; border-radius: 12px;
      padding: 20px; text-align: center;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    #menuLogo { max-width: 80%; margin-bottom: 20px; }
    .menu-buttons { display: flex; flex-direction: column; gap: 10px; }
    .menu-buttons button {
      padding: 12px; border: 2px solid #5a5348; border-radius: 10px;
      background: #1e1d1b; color: #fff; cursor: pointer; font-size: 18px;
    }
    .menu-buttons button:active { transform: translateY(1px); }

    :root { --bg:#2b2a27; --panel:#1e1d1b; }
    html,body{height:100%;margin:0;background:var(--bg);font-family:system-ui,Segoe UI,Roboto,Arial;overflow:hidden}
    .wrap{display:grid;place-items:center;height:100%;padding:0}
    canvas{image-rendering: pixelated; image-rendering: crisp-edges; background:#e3cda1; outline:3px solid #4b3a2a; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .bar{display:flex;gap:8px;align-items:center;justify-content:center;color:#fff;opacity:.9;margin-top:6px}
    .btn{background:var(--panel);border:2px solid #5a5348;border-radius:10px;padding:8px 12px;cursor:pointer}
    .btn:active{transform:translateY(1px)}
    .btn:focus{outline:none}
    .touch{position:fixed;left:0;right:0;bottom:14px;display:flex;justify-content:center;gap:16px;pointer-events:auto}
    .tbtn{font-size:22px;width:64px;height:64px;border-radius:12px}
    /* --- Game Over HTML --- */
    #goBackdrop{
      position:fixed; inset:0; display:none;
      align-items:center; justify-content:center;
      background:rgba(0,0,0,.65); z-index:9999;
    }
    #goPanel{
      background:#f7d0a4; color:#2b2a27;
      width:min(520px,86vw); border:4px solid #4b3a2a;
      border-radius:12px; padding:20px; text-align:center;
      box-shadow:0 10px 30px rgba(0,0,0,.35);
    }
    #goPanel img{ max-width:100%; height:auto; display:block; margin:0 auto 12px; }
    #goPanel p{ margin:0 0 12px; font:16px/1.4 monospace; }
    #goPanel button{
      padding:10px 16px; border:2px solid #5a5348; border-radius:10px;
      background:#1e1d1b; color:#fff; cursor:pointer;
    }
    #goPanel button:active{ transform:translateY(1px); }

    @media (pointer:fine){ .touch{display:none} }
  </style>
</head>
<body>
  <div id="menuBackdrop">
    <div id="menuPanel">
      <img src="./img/logo.png" alt="Logo do jogo" id="menuLogo" />
      <div class="menu-buttons">
        <button id="menuStartBtn">‚ñ∂Ô∏è START</button>
        <button id="menuInstrBtn">üìú INSTRU√á√ïES</button>
      </div>
      <p id="menuInstrText" style="display:none; margin-top: 16px; font-size: 16px; line-height: 1.4;">
        üìú <b>Como jogar:</b><br>
        Clique na tela para mudar a dire√ß√£o do designer e desviar dos objetos.<br>
        Colete caf√©s para ganhar pontos.<br>
        Evite tudo o que n√£o for caf√©!
      </p>
    </div>
  </div>

  <div class="wrap">
    <canvas id="game" width="540" height="960" aria-label="Designer vs Editor (mobile)"></canvas>
    <div class="bar">
      <button id="startBtn" class="btn">‚ñ∂Ô∏è Jogar</button>
      <button id="muteBtn" class="btn">üîà</button>
      <button id="resetBtn" class="btn">‚ü≤</button>
      <div id="goBackdrop" aria-hidden="true">
        <div id="goPanel">
          <img src="./img/gameover.png" alt="Game Over" />
          <h2 style="font-size: 32px; font-weight: bold; margin-bottom: 10px;">
            VOC√ä SOFREU UM BURNOUT!!!
          </h2>
          <p style="font-size: 24px;">Tire 1 ano sab√°tico e tente novamente.</p>
          <p id="goTime" style="font-size:20px; margin:8px 0 0 0;"></p>
          <p id="goBest" style="font-size:14px; opacity:.8;"></p>
          <button id="restartBtn">Reiniciar</button>
        </div>
      </div>
    </div>
  </div>

  <div class="touch">
    <button class="btn tbtn" id="left"  tabindex="-1">‚¨Ö</button>
    <button class="btn tbtn" id="right" tabindex="-1">‚û°</button>
  </div>

  <button id="pauseBtn" class="btn" style="
    position: fixed;
    left: 18px;
    bottom: 18px;
    z-index: 10001;
    font-size: 22px;
    padding: 12px 18px;
    color: #fff;">‚è∏Ô∏è Pause</button>

<script>
(() => {
  const W = 540, H = 960;
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d');
  const ui = { start:byId('startBtn'), reset:byId('resetBtn'), mute:byId('muteBtn'), left:byId('left'), right:byId('right') };
// No topo do script, adicione:
let lastMusicLevelTrigger = 1;

// Fun√ß√£o para calcular o trigger de n√≠vel (a cada 2 n√≠veis)
function getMusicLevelTrigger(level) {
  return Math.floor((level - 1) / MUSIC_SPEED.LEVELS_PER_STEP); // LEVELS_PER_STEP = 2
}
  // Bloqueia setas/space de interferirem (scroll/hist√≥rico)
  addEventListener('keydown', e=>{
    if (['ArrowLeft','ArrowRight',' '].includes(e.key) || (e.altKey && (e.key==='ArrowLeft'||e.key==='ArrowRight')))
      e.preventDefault();
  }, {passive:false});

  // HTML de Game Over
  const go = { back: byId('goBackdrop'), restart: byId('restartBtn') };
  function showGameOverHTML(){ go.back.style.display = 'flex'; go.back.setAttribute('aria-hidden','false'); }
  function hideGameOverHTML(){ go.back.style.display = 'none'; go.back.setAttribute('aria-hidden','true'); }

  // --- MENU PRINCIPAL ---
  const menu = {
    back: document.getElementById('menuBackdrop'),
    start: document.getElementById('menuStartBtn'),
    instr: document.getElementById('menuInstrBtn'),
    instrText: document.getElementById('menuInstrText')
  };

  // ===== Config global da velocidade da trilha =====
  const MUSIC_SPEED = { BASE:0.8, STEP:0.05, LEVELS_PER_STEP:2, MIN:0.2, MAX:2.0 };
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

 // === AUDIO MANAGER (loop simples, sem crossfade) ===
const AudioManager = (() => {
  // ---- constantes de timing
  const LOOKAHEAD_SEC       = 0.050; // checagem do scheduler
  const SCHEDULE_AHEAD_SEC  = 1.000; // janela de agendamento
  const MIN_AHEAD           = 0.200; // NUNCA agendar a menos que 200ms no futuro
  const MIN_SEG_WALL        = 0.020; // segmento m√≠nimo (anti‚Äëglitch)

  // ---- estado b√°sico
  let ctx=null, unlocked=false;
  let masterGain, musicGain, sfxGain;
  let useMediaElement=false, mediaEl=null;
  let musicTargetVol=0.8, musicRate=0.8; // come√ßa em ‚Äúslow motion‚Äù
  const buffers=new Map(), activeSfx=new Set();
  const activeSeg=new Set();
  let currentMusicBuf=null;

  // meta do loop
  const musicMeta = { loopStart:0, loopEnd:null, epsilonSec:0 };

  // timeline
  let schedId=null, playing=false;
  let nextWhen=0, nextOffset=0, nextLen=0;
  let loopStart=0, loopEnd=0, loopLen=0;
  let musicStartTime=0, musicPauseOffset=0;

  // utils
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const t=()=>ctx?ctx.currentTime:0;
  const pick=a=>a[0]||null;
  function killSegments(){
    for(const n of Array.from(activeSeg)) {
      try{ n.stop(0); }catch(_){} } activeSeg.clear();
  }
  function ensureContext(){
    if (!ctx){
      ctx = new (window.AudioContext||window.webkitAudioContext)();
      masterGain = ctx.createGain();
      musicGain  = ctx.createGain();
      sfxGain    = ctx.createGain();
      masterGain.gain.value = 1;
      musicGain.gain.value  = musicTargetVol;
      sfxGain.gain.value    = 1;
      musicGain.connect(masterGain);
      sfxGain.connect(masterGain);
      masterGain.connect(ctx.destination);
    }
  }
  async function fetchAB(u){
    const r=await fetch(u);
    if(!r.ok) throw new Error('Falha ao buscar '+u);
    return await r.arrayBuffer();
  }
  async function decode(u){
    ensureContext(); const ab=await fetchAB(u);
    return await ctx.decodeAudioData(ab);
  }

  // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  // AQUI EST√Å A MUDAN√áA PRINCIPAL:
  // A fun√ß√£o `scheduleOne` foi simplificada para n√£o ter mais fade-in/fade-out.
  // Ela agora apenas toca o som com volume 100%.
  function scheduleOne(when, offset, dur){
    const src = ctx.createBufferSource();
    src.buffer = currentMusicBuf;
    src.playbackRate.value = musicRate;

    const g = ctx.createGain();
    src.connect(g); g.connect(musicGain);

    // Sem fades, apenas define o volume constante
    g.gain.setValueAtTime(1, when);

    src.start(when, offset, dur);

    activeSeg.add(src);
    src.onended = () => {
      activeSeg.delete(src);
      try{ src.disconnect(); g.disconnect();
         }catch(_){

         }
    };
  }
  // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  function stopScheduler(){
    playing=false;
    if (schedId){ clearInterval(schedId);
                  schedId=null; }
  }

  function startScheduler(){
    stopScheduler();
    playing = true;

    schedId = setInterval(() => {
      if (!playing || !currentMusicBuf) return;

      const now = t();
      if (nextWhen < now + MIN_AHEAD) nextWhen = now + MIN_AHEAD;

      while (nextWhen < now + SCHEDULE_AHEAD_SEC) {
        scheduleOne(nextWhen, nextOffset, nextLen);

        const segWall  = Math.max(MIN_SEG_WALL, nextLen / musicRate);
        const advance  = segWall; // Avan√ßa o tempo exato da dura√ß√£o do segmento

        nextWhen   = nextWhen + advance; // O pr√≥ximo come√ßa exatamente onde este termina
        nextOffset = loopStart;          // a partir do loopStart
        nextLen    = loopLen;            // tamanho padr√£o do la√ßo
      }
    }, LOOKAHEAD_SEC * 1000);
  }

  function recalcLoopMeta(){
    loopStart = musicMeta.loopStart;
    loopEnd   = musicMeta.loopEnd ?? currentMusicBuf.duration;
    loopLen   = Math.max(0.001, loopEnd - loopStart);
  }

  return {
    async unlock(){ ensureContext(); if (ctx.state==='suspended'){ try{ await ctx.resume(); }catch{} } unlocked=true; },

    async preload(m={}){
      ensureContext();
      const wantBuffer = !!m.music?.forceBuffer;

      if (m.music?.src?.length){
        let dec=null;
        for (const u of m.music.src){ try{ dec=await decode(u); break; }catch(_){} }
        if (dec){ currentMusicBuf=dec; useMediaElement=false; }
        else{
          if (wantBuffer) throw new Error('forceBuffer=true mas nenhum src decodificou.');
          useMediaElement=true; mediaEl=new Audio();
          mediaEl.loop=true; mediaEl.preload='auto'; mediaEl.src=pick(m.music.src);
        }

        musicMeta.loopStart = m.music.loopStart ?? 0;
        musicMeta.loopEnd   = m.music.loopEnd   ?? null;

        if (currentMusicBuf){
          const sr = currentMusicBuf.sampleRate||44100;
          musicMeta.epsilonSec = 1/sr;
          if (musicMeta.loopEnd == null) musicMeta.loopEnd = currentMusicBuf.duration - musicMeta.epsilonSec;
          musicMeta.loopStart = Math.max(0, Math.min(musicMeta.loopStart, currentMusicBuf.duration - 0.001));
          musicMeta.loopEnd   = Math.max(musicMeta.loopStart + 0.001, Math.min(musicMeta.loopEnd, currentMusicBuf.duration));
          recalcLoopMeta();
        }
      }

      if (m.sfx){
        await Promise.all(Object.entries(m.sfx).map(async([n,srcs])=>{
          let d=null; for(const u of srcs){ try{ d=await decode(u); break; }catch(_){} }
          if (d) buffers.set(n,d); else console.warn(`SFX '${n}' n√£o carregou`);
        }));
      }
    },

    playMusic({fade=0.5}={}){
      if (!unlocked){ console.warn('chame unlock() ap√≥s gesto'); return; }

      if (useMediaElement){
        if (!mediaEl) return;
        mediaEl.playbackRate = musicRate;
        mediaEl.volume = 0; mediaEl.play().catch(()=>{});
        if (fade>0){
          const t0=performance.now(), dur=fade*1000;
          const iv=setInterval(()=>{ const p=Math.min(1,(performance.now()-t0)/dur); mediaEl.volume=musicTargetVol*p; if(p>=1) clearInterval(iv); },33);
        } else mediaEl.volume = musicTargetVol;
        return;
      }

      if (!currentMusicBuf) return;

      stopScheduler(); killSegments(); recalcLoopMeta();

      let offset = musicPauseOffset ? (musicPauseOffset % loopLen) + loopStart : loopStart;
      if (offset < loopStart || offset >= loopEnd) offset = loopStart;

      nextOffset = offset;
      nextLen    = Math.max(0.001, loopEnd - offset);
      nextWhen   = t() + MIN_AHEAD; // folga garantida

      // fade no bus da m√∫sica (mantido para o in√≠cio/pausa)
      if (fade > 0) {
        musicGain.gain.setValueAtTime(0, t());
        musicGain.gain.linearRampToValueAtTime(musicTargetVol, t() + fade);
      } else {
        musicGain.gain.setValueAtTime(musicTargetVol, t());
      }

      musicStartTime   = t() - (offset - loopStart);
      musicPauseOffset = 0;

      startScheduler();
    },

    pauseMusic({fade=0.25}={}){
      if (useMediaElement){
        if (!mediaEl) return;
        const start=mediaEl.volume, t0=performance.now(), dur=fade*1000;
        const iv=setInterval(()=>{ const p=Math.min(1,(performance.now()-t0)/dur); mediaEl.volume=start*(1-p); if(p>=1){ clearInterval(iv); mediaEl.pause(); mediaEl.volume=start; } },33);
        return;
      }
      if (!currentMusicBuf) return;

      const elapsed = t() - musicStartTime;
      const inner   = ((elapsed * musicRate) % loopLen + loopLen) % loopLen;
      musicPauseOffset = inner;

      if (fade > 0) {
        musicGain.gain.cancelScheduledValues(t());
        musicGain.gain.setValueAtTime(musicGain.gain.value, t());
        musicGain.gain.linearRampToValueAtTime(0, t() + fade);
        setTimeout(()=>{ stopScheduler(); killSegments(); }, Math.max(1, fade*1000));
      } else {
        musicGain.gain.setValueAtTime(0, t());
        stopScheduler(); killSegments();
      }
    },

    setMusicRate(r){
      r = clamp(r, 0.5, 2.0);
      musicRate = r;

      if (useMediaElement){ if (mediaEl) mediaEl.playbackRate = r; return; }
      if (!currentMusicBuf) return;

      const elapsed = t() - musicStartTime;
      musicPauseOffset = ((elapsed * musicRate) % loopLen + loopLen) % loopLen;

      stopScheduler(); killSegments();
      this.playMusic({fade:0.05}); // retoma no novo rate, com micro‚Äëfade
    },

    playSfx(n,{volume=1,detune=0}={}){
      if (!unlocked) return;
      const b=buffers.get(n); if(!b) return;
      const src=ctx.createBufferSource(); src.buffer=b;
      if (src.detune) src.detune.value=detune;
      const g=ctx.createGain(); g.gain.value=clamp(volume,0,1);
      src.connect(g); g.connect(sfxGain); src.start(0);
      activeSfx.add(src); src.onended=()=>activeSfx.delete(src);
    },

    setMasterVolume(v){ masterGain.gain.setValueAtTime(clamp(v,0,1), t()); },
    setMusicVolume(v){ musicTargetVol = clamp(v,0,1); musicGain.gain.linearRampToValueAtTime(musicTargetVol, t()+0.05); },

    handleVisibility(){
      if (document.hidden){ this._wasPlaying = playing; this.pauseMusic({fade:0.2}); }
      else if (this._wasPlaying){ setTimeout(()=>this.playMusic({fade:0.3}), 120); }
    }
  };
})();


  document.addEventListener('visibilitychange', AudioManager.handleVisibility.bind(AudioManager));

  // === PRELOAD DE √ÅUDIO ===
  (async function preloadAudio(){
    try{
      await AudioManager.preload({
        music: { src: ['./audio/music.ogg','./audio/music.mp3'], forceBuffer: true },
        sfx:   { click:['./audio/click.ogg','./audio/click.mp3'], hit:['./audio/hit.ogg','./audio/hit.mp3'] }
      });
    }catch(e){ console.warn('Preload de √°udio falhou:', e); }
  })();

  // === Spawn Config ===
  const CONFIG = {
    bagSize: 10,
    coffeePer10ByLevel: [
      { lvl: 1, coffee: 3 },
      { lvl: 8, coffee: 2 },
      { lvl: 15, coffee: 1 },
    ],
    lifeEvery: 15,
    maxLives: 5,
    hazardTypes: ['paper','imageIcon','request','graphic','graphic2']
  };
  function coffeePer10ForLevel(lvl){
    let val = 3;
    for (const step of CONFIG.coffeePer10ByLevel) if (lvl >= step.lvl) val = step.coffee;
    return val;
  }

  // Mostrar/Ocultar menu
  function showMenu() { menu.back.style.display = 'flex'; }
  function hideMenu() { menu.back.style.display = 'none'; }

  // START ‚Äî desbloqueia e inicia m√∫sica
  menu.start.onclick = async () => {
    await AudioManager.unlock();
    AudioManager.playMusic({fade:0.6});
    AudioManager.playSfx('click',{volume:0.8});
    hideMenu();
    reset();
    start();
  };

  // INSTRU√á√ïES
  menu.instr.onclick = () => {
    menu.instrText.style.display =
      menu.instrText.style.display === 'none' ? 'block' : 'none';
  };

  // --- Layout ---
  const HUD_TOP = 84;
  const HUD_BOTTOM = 72;
  const PLAY_Y_MIN = HUD_TOP + 8;
  const PLAY_Y_MAX = H - HUD_BOTTOM;

  // Reiniciar a partir da tela HTML
  go.restart.onclick = ()=>{ reset(); start(); };

  function byId(id){ return document.getElementById(id); }

  function fit(){ const s=Math.min(innerWidth/W, innerHeight/H); cvs.style.width=W*s+'px'; cvs.style.height=H*s+'px'; }
  addEventListener('resize', fit); fit();

  // Velocidade do jogador
  const PLAYER_BASE_SPEED = 4;
  const PLAYER_LEVEL_MULT = 0.05;

  // --- Sprites externos (tolerante a falhas) ---
  const sprites = {};
  const spritePath = "./img/";
  function loadImage(name, file) {
    return new Promise((resolve) => {
      const img = new Image();
      img.src = spritePath + file;
      img.onload = async () => { try{ if (img.decode) await img.decode(); }catch(_){} sprites[name] = img; resolve(); };
      img.onerror = () => { console.warn('Falha ao carregar sprite:', file); resolve(); };
    });
  }
  const imageFiles = [
    ["editor", "editor.png"],
    ["designer", "designer.png"],
    ["coffee", "coffee.png"],
    ["paper", "destaque.png"],
    ["imageIcon", "foto.png"],
    ["request", "mapa.png"],
    ["graphic", "grafico1.png"],
    ["ferias","ferias.png"],
    ["logo", "logo.png"],
    ["gameover", "gameover.png"],
    ["graphic2", "pizza.png"],
    ["pizza", "salario.png"],
    ["heart", "vida.png"]
  ];
 
  function drawSprite(name,x,y,w,h){
    const img = sprites[name];
    if(!img) return;
    if (w&&h) ctx.drawImage(img,x,y,w,h);
    else ctx.drawImage(img,x,y); }

  const rand=(a,b)=>Math.random()*(b-a)+a;
  const clamp2=(v,a,b)=>Math.max(a,Math.min(b,v));
 
  function rect(A,B){
    return !(A.x+A.w<B.x||B.x+B.w<A.x||A.y+A.h<B.y||B.y+B.h<A.y)
  }

  const state = {
    running:false, gameOver:false, t:0, score:0, coffee:0, lives:3, level:1,
    player:{x:W/2-24,y:H-90,w:48,h:48,vx:1,dir:1},
    editor:{ x:W/2-24, y:PLAY_Y_MIN, w:48, h:48, vx:3 },
    items:[],
    totalSpawns: 0
  };

  let spawnBag = [];
  let lifeCounter = 0;

  // TIMER
  const storedBest = +localStorage.getItem('best_survival_ms') || 0;
  const timer = { accum: 0, start: 0, running: false, best: storedBest };
  function timerStart(){ timer.start = performance.now(); timer.running = true; }
  function timerPause(){ if (!timer.running) return; timer.accum += performance.now() - timer.start; timer.running = false; }
  function timerResume(){ if (timer.running) return; timer.start = performance.now(); timer.running = true; }
  function timerReset(){ timer.accum = 0; timer.running = false; timer.start = 0; }
  function getElapsedMs(){ return timer.accum + (timer.running ? performance.now() - timer.start : 0); }
  function fmtClock(ms, withCs=false){
    ms = Math.max(0, Math.floor(ms));
    const m = Math.floor(ms/60000);
    const s = Math.floor((ms%60000)/1000);
    const base = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    if (!withCs) return base;
    const cs = Math.floor((ms%1000)/10);
    return `${base}.${String(cs).padStart(2,'0')}`;
  }

  const speedMult = ()=> 1 + Math.floor(state.coffee/3)*0.05;

  function reset(){
    state.running=false; state.gameOver=false; state.t=0;
    state.score=0; state.coffee=0; state.level=1; state.lives=3;
    state.player.x=W/2-24; state.player.dir=1; state.player.vx=1;
    state.editor.x=W/2-24; state.editor.vx=3;
    state.items.length=0; hideGameOverHTML();
    state.totalSpawns = 0;
    timerReset();
    spawnBag.length = 0;
    lifeCounter = 0;
    draw(0); drawStart();
  }

  function refillSpawnBag(){
    const bagSize = CONFIG.bagSize;
    const coffees = Math.min(coffeePer10ForLevel(state.level), bagSize);
    const hazards = Math.max(0, bagSize - coffees);
    spawnBag.length = 0;
    for (let i = 0; i < coffees; i++) spawnBag.push('coffee');
    for (let i = 0; i < hazards; i++) {
      const t = CONFIG.hazardTypes[i % CONFIG.hazardTypes.length];
      spawnBag.push(t);
    }
    for (let i = spawnBag.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [spawnBag[i], spawnBag[j]] = [spawnBag[j], spawnBag[i]];
    }
  }

  function nextSpawnType(){
    if (spawnBag.length === 0) refillSpawnBag();
    let type = spawnBag.pop();
    if (CONFIG.lifeEvery > 0) {
      lifeCounter++;
      if (lifeCounter >= CONFIG.lifeEvery) {
        if (type === 'coffee') {
          const hazardIdx = spawnBag.findIndex(t => t !== 'coffee');
          if (hazardIdx !== -1) { const hazard = spawnBag[hazardIdx]; spawnBag[hazardIdx] = 'coffee'; type = hazard; }
        }
        type = 'pizza';
        lifeCounter = 0;
      }
    }
    return type;
  }

  function spawn(){
    const type = nextSpawnType();
    const x = clamp2(state.editor.x+24+rand(-60,60), 16, W-16-48);
    const y = state.editor.y+40;
    const baseVY = rand(2.2,4.2) + state.level*0.2;
    state.items.push({ x, y, w:48, h:48, vy:baseVY, type, sway:rand(-0.6,0.6) });
    state.totalSpawns++;
  }

  // Clique/Toque no canvas: inverte dire√ß√£o
  cvs.addEventListener('pointerdown', ()=>{
    if (!state.gameOver) state.player.dir *= -1; });

  function start(){
    if(state.gameOver) reset();
    state.running = true;
    ui.start.textContent = '‚è∏Ô∏é Pausar';
    document.getElementById('pauseBtn').textContent = '‚è∏Ô∏è Pause';
    AudioManager.playMusic({fade:0.6});
    timerStart();
    loop();
  }

  function togglePause(){
    state.running = !state.running;
    if (state.running){
      ui.start.textContent = '‚è∏Ô∏é Pausar';
      document.getElementById('pauseBtn').textContent = '‚è∏Ô∏è Pause';
      AudioManager.playMusic({fade:0.3});
      timerResume();
      loop();
    } else {
      ui.start.textContent = '‚ñ∂Ô∏è Continuar';
      document.getElementById('pauseBtn').textContent = '‚ñ∂Ô∏è Continuar';
      AudioManager.pauseMusic({fade:0.2});
      timerPause();
    }
  }

  ui.start.onclick=()=>{
    if(!state.running && !state.gameOver) start();
    else togglePause(); };
  ui.reset.onclick=reset;

  let muted = false;
  ui.mute.onclick=()=> {
    muted = !muted;
    if (muted) { AudioManager.setMasterVolume?.(0); ui.mute.textContent = 'üîá'; }
    else { AudioManager.setMasterVolume?.(1); ui.mute.textContent = 'üîà'; }
  };

  const pauseBtn = document.getElementById('pauseBtn');
  pauseBtn.onclick = togglePause;

  function loop(){ if(!state.running) return;
                    requestAnimationFrame(loop); update(); draw(); }

  // ===== M√∫sica acelera 0.1x a cada 2 n√≠veis (come√ßa lenta) =====
  let lastAppliedRate = MUSIC_SPEED.BASE;
  function rateForLevel(lvl){
    const steps = Math.floor(Math.max(1, lvl - 1) / MUSIC_SPEED.LEVELS_PER_STEP);
    return clamp(MUSIC_SPEED.BASE + steps * MUSIC_SPEED.STEP, MUSIC_SPEED.MIN, MUSIC_SPEED.MAX);
  }

  function update(){
    state.t++;
    state.level = 1 + Math.floor(state.coffee/3);
const musicLevelTrigger = getMusicLevelTrigger(state.level);
  if (musicLevelTrigger !== lastMusicLevelTrigger) {
    const desiredRate = rateForLevel(state.level);
    AudioManager.setMusicRate(desiredRate); // reinicia com crossfade
    lastMusicLevelTrigger = musicLevelTrigger;
  }
    const desiredRate = rateForLevel(state.level);
    if (Math.abs(desiredRate - lastAppliedRate) > 1e-4){
      AudioManager.setMusicRate(desiredRate);
      lastAppliedRate = desiredRate;
    }

    state.editor.x += state.editor.vx * speedMult();
    if(state.editor.x<16 || state.editor.x>W-16-state.editor.w){
      state.editor.vx*=-1; state.editor.x=clamp2(state.editor.x,16,W-16-state.editor.w);
    }

    const spawnRate = Math.max(24, (80 - state.level*5) / speedMult());
    if(state.t % Math.floor(spawnRate) === 0) spawn();

    const p = state.player;
    p.vx = p.dir;
    const v = PLAYER_BASE_SPEED * (1 + (state.level - 1) * PLAYER_LEVEL_MULT);
    p.x += p.vx * v;

    if (p.x <= 16){ p.x = 16; p.dir = 1; }
    else if (p.x >= W-16-p.w){ p.x = W-16-p.w; p.dir = -1; }

    for(const it of state.items){ it.x += it.sway * speedMult()*0.6; it.y += it.vy * speedMult(); }

    for(let i=state.items.length-1;i>=0;i--){
      const it=state.items[i];
      if(it.y>H+60){ state.items.splice(i,1); continue; }
      if(rect({x:p.x,y:p.y,w:p.w,h:p.h},{x:it.x,y:it.y,w:it.w,h:it.h})){
        state.items.splice(i,1);
        if (it.type === 'coffee'){ state.coffee++; state.score += 5; AudioManager.playSfx('click',{volume:0.8}); }
        else if (it.type === 'pizza'){
          if (state.lives < CONFIG.maxLives) state.lives++; else state.score += 10;
          AudioManager.playSfx('click',{volume:0.8});
        } else {
          state.lives--; AudioManager.playSfx('hit',{volume:1.0});
          if (state.lives <= 0) { gameOver(); break; }
        }
      }
    }
  }

  function gameOver(){
    state.running = false;
    state.gameOver = true;
    AudioManager.pauseMusic({fade:0.2});
    timerPause();
    const elapsed = getElapsedMs();
    if (elapsed > timer.best){ timer.best = elapsed; localStorage.setItem('best_survival_ms', String(timer.best)); }
    const goTimeEl = document.getElementById('goTime');
    const goBestEl = document.getElementById('goBest');
    if (goTimeEl) goTimeEl.textContent  = 'Voc√™ sobreviveu por ' + fmtClock(elapsed, true);
    if (goBestEl) goBestEl.textContent  = 'Melhor tempo: ' + fmtClock(timer.best, true);
    showGameOverHTML();
  }

  function drawBg(){ ctx.fillStyle='#d9bd93'; ctx.fillRect(0,0,W,H); }

  function drawHUD(){
    ctx.font = '24px monospace';
    ctx.fillStyle = '#2b2a27';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    for(let i=0;i<state.lives;i++){
      const totalW = state.lives*20 + (state.lives-1)*10;
      const x = W/2 - totalW/2 + i*30;
      const y = H-40;
      drawSprite('heart', x, y, 20, 20);
    }
    drawSprite('coffee', 16, 40, 48, 48);
    ctx.fillText('x '+state.coffee, 86, 52);
    ctx.font = '20px monospace';
    ctx.fillText(String(state.score).padStart(4,'0'), 86, 74);
    ctx.font = '24px monospace';
    ctx.textAlign = 'right';
    ctx.fillText(fmtClock(getElapsedMs(), false), W-24, 52);
  }

  function draw(){
    ctx.clearRect(0,0,W,H);
    drawBg();
    ctx.save(); ctx.globalAlpha=0.08; ctx.fillStyle='#000'; ctx.font='80px monospace'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('LVL '+state.level, W/2, H/2); ctx.restore();
    drawSprite('editor', state.editor.x, state.editor.y, 48, 48);
    drawSprite('designer', state.player.x, state.player.y, 48, 48);
    for(const it of state.items){ drawSprite(it.type, it.x, it.y, 48, 48); }
    drawHUD();
  }

  function drawStart(){ ctx.fillStyle='rgba(0,0,0,.25)'; ctx.fillRect(0,0,W,H); }

  // Game Over (HTML) j√° √© usado; esta vers√£o canvas n√£o √© necess√°ria agora

  // Clique no canvas no GO para reiniciar (fallback)
  cvs.addEventListener('pointerdown', (e) => {
    if (!state.gameOver) return;
    reset(); start();
  });

  Promise.all(imageFiles.map(([n, f]) => loadImage(n, f))).then(() => {
    reset(); draw(); showMenu();
  });

})();
</script>
</body>
</html>
