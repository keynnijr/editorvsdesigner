<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Designer vs Editor ‚Äî Mobile 9:16 (v3)</title>
  <style>
    /* --- MENU PRINCIPAL --- */
    #menuBackdrop {
      position: fixed; inset: 0;
      display: flex; align-items: center; justify-content: center;
      background: rgba(0,0,0,.65); z-index: 10010;
    }
    #menuPanel {
      background: #f7d0a4; color: #2b2a27;
      width: min(520px, 86vw);
      border: 4px solid #4b3a2a; border-radius: 12px;
      padding: 20px; text-align: center;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    #menuLogo { max-width: 80%; margin-bottom: 20px; }
    .menu-buttons { display: flex; flex-direction: column; gap: 10px; }
    .menu-buttons button {
      padding: 12px; border: 2px solid #5a5348; border-radius: 10px;
      background: #1e1d1b; color: #fff; cursor: pointer; font-size: 18px;
    }
    .menu-buttons button:active { transform: translateY(1px); }

    :root { --bg:#2b2a27; --panel:#1e1d1b; }
    html,body{height:100%;margin:0;background:var(--bg);font-family:system-ui,Segoe UI,Roboto,Arial;overflow:hidden}
    .wrap{display:grid;place-items:center;height:100%;padding:0}
    canvas{image-rendering: pixelated; image-rendering: crisp-edges; background:#e3cda1; outline:3px solid #4b3a2a; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .bar{display:flex;gap:8px;align-items:center;justify-content:center;color:#fff;opacity:.9;margin-top:6px}
    .btn{background:var(--panel);border:2px solid #5a5348;border-radius:10px;padding:8px 12px;cursor:pointer}
    .btn:active{transform:translateY(1px)}
    .btn:focus{outline:none}
    .touch{position:fixed;left:0;right:0;bottom:14px;display:flex;justify-content:center;gap:16px;pointer-events:auto}
    .tbtn{font-size:22px;width:64px;height:64px;border-radius:12px}
    /* --- Game Over HTML --- */
    #goBackdrop{
      position:fixed; inset:0; display:none;
      align-items:center; justify-content:center;
      background:rgba(0,0,0,.65); z-index:9999;
    }
    #goPanel{
      background:#f7d0a4; color:#2b2a27;
      width:min(520px,86vw); border:4px solid #4b3a2a;
      border-radius:12px; padding:20px; text-align:center;
      box-shadow:0 10px 30px rgba(0,0,0,.35);
    }
    #goPanel img{ max-width:100%; height:auto; display:block; margin:0 auto 12px; }
    #goPanel p{ margin:0 0 12px; font:16px/1.4 monospace; }
    #goPanel button{
      padding:10px 16px; border:2px solid #5a5348; border-radius:10px;
      background:#1e1d1b; color:#fff; cursor:pointer;
    }
    #goPanel button:active{ transform:translateY(1px); }

    @media (pointer:fine){ .touch{display:none} }
  </style>
</head>
<body>
  <div id="menuBackdrop">
    <div id="menuPanel">
      <img src="./img/logo.png" alt="Logo do jogo" id="menuLogo" />
      <div class="menu-buttons">
        <button id="menuStartBtn">‚ñ∂Ô∏è START</button>
        <button id="menuInstrBtn">üìú INSTRU√á√ïES</button>
      </div>
      <p id="menuInstrText" style="display:none; margin-top: 16px; font-size: 16px; line-height: 1.4;">
        üìú <b>Como jogar:</b><br>
        Clique na tela para mudar a dire√ß√£o do designer e desviar dos objetos.<br>
        Colete caf√©s para ganhar pontos.<br>
        Evite tudo o que n√£o for caf√©!
      </p>
    </div>
  </div>

  <div class="wrap">
    <canvas id="game" width="540" height="960" aria-label="Designer vs Editor (mobile)"></canvas>
    <div class="bar">
      <button id="muteBtn" class="btn">üîà</button>
      <button id="resetBtn" class="btn">‚ü≤</button>
      <div id="goBackdrop" aria-hidden="true">
        <div id="goPanel">
          <img src="./img/gameover.png" alt="Game Over" />
          <h2 style="font-size: 32px; font-weight: bold; margin-bottom: 10px;">
            VOC√ä SOFREU UM BURNOUT!!!
          </h2>
          <p style="font-size: 24px;">Tire 1 ano sab√°tico e tente novamente.</p>
          <p id="goTime" style="font-size:20px; margin:8px 0 0 0;"></p>
          <p id="goBest" style="font-size:14px; opacity:.8;"></p>
          <button id="restartBtn">Reiniciar</button>
        </div>
      </div>
    </div>
  </div>

  <div class="touch">
    <button class="btn tbtn" id="left"  tabindex="-1">‚¨Ö</button>
    <button class="btn tbtn" id="right" tabindex="-1">‚û°</button>
  </div>

  <button id="pauseBtn" class="btn" style="
    position: fixed;
    left: 18px;
    bottom: 18px;
    z-index: 10001;
    font-size: 22px;
    padding: 12px 18px;
    color: #fff;">‚è∏Ô∏è Pause</button>

<script>
(() => {
  const W = 540, H = 960;
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d');
  const ui = { start: byId('menuStartBtn'),
    reset: byId('resetBtn'),
    mute: byId('muteBtn'),
    left: byId('left'),
    right: byId('right') };
  // No topo do script, adicione:
  let lastMusicLevelTrigger = 1;

  // Fun√ß√£o para calcular o trigger de n√≠vel (a cada 2 n√≠veis)
  function getMusicLevelTrigger(level) {
    return Math.floor((level - 1) / MUSIC_SPEED.LEVELS_PER_STEP); // LEVELS_PER_STEP = 2
    }
  // Bloqueia setas/space de interferirem (scroll/hist√≥rico)
  addEventListener('keydown', e=>{
    if (['ArrowLeft','ArrowRight',' '].includes(e.key) || (e.altKey && (e.key==='ArrowLeft'||e.key==='ArrowRight')))
      e.preventDefault();
    }, {passive:false});

  // HTML de Game Over
  const go = { back: byId('goBackdrop'), restart: byId('restartBtn') };
  function showGameOverHTML(){ go.back.style.display = 'flex'; go.back.setAttribute('aria-hidden','false'); }
  function hideGameOverHTML(){ go.back.style.display = 'none'; go.back.setAttribute('aria-hidden','true'); }

  // --- MENU PRINCIPAL ---
  const menu = {
    back: document.getElementById('menuBackdrop'),
    start: document.getElementById('menuStartBtn'),
    instr: document.getElementById('menuInstrBtn'),
    instrText: document.getElementById('menuInstrText')};

    // ===== Config global da velocidade da trilha =====
    const MUSIC_SPEED = { BASE:0.8, STEP:0.05, LEVELS_PER_STEP:2, MIN:0.2, MAX:2.0 };
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

    // === AUDIO MANAGER (com loop nativo e preciso) ===
    const AudioManager = (() => {
    // ---- estado b√°sico
    let ctx=null, unlocked=false;
    let masterGain, musicGain, sfxGain;
    
    let musicTargetVol=0.8, musicRate=0.2;
    const buffers=new Map();
    let currentMusicBuf=null, musicSource=null;
    
    // meta do loop
    const musicMeta = { loopStart:0, loopEnd:null };

    // estado de pausa
    let musicPauseOffset=0, musicStartTime=0, isPlaying=false;

    // utils
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const t=()=>ctx?ctx.currentTime:0;
  
  function ensureContext(){
    if (!ctx){
      ctx = new (window.AudioContext||window.webkitAudioContext)();
      masterGain = ctx.createGain();
      musicGain  = ctx.createGain();
      sfxGain    = ctx.createGain();
      masterGain.gain.value = 1;
      musicGain.gain.value  = musicTargetVol;
      sfxGain.gain.value    = 1;
      musicGain.connect(masterGain);
      sfxGain.connect(masterGain);
      masterGain.connect(ctx.destination);
      }
  }
  async function fetchAB(u){
    const r=await fetch(u);
    if(!r.ok) throw new Error('Falha ao buscar '+u);
    return await r.arrayBuffer();
    }
  async function decode(u){
    ensureContext(); const ab=await fetchAB(u);
    return await ctx.decodeAudioData(ab);
  }   

  function stopMusicSource() {
    if (musicSource) {
      try {
        musicSource.stop(0);
        musicSource.disconnect();
        } catch(_) {}
      musicSource = null;
      }
    isPlaying = false;
    }

  return {
    async unlock(){ ensureContext(); if (ctx.state==='suspended'){ try{ await ctx.resume(); }catch{} } unlocked=true; },

    async preload(m={}){
      ensureContext();
      if (m.music?.src?.length){
        let dec=null;
        for (const u of m.music.src){ try{ dec=await decode(u); break; }catch(_){} }
        if (dec) currentMusicBuf = dec;
        
        musicMeta.loopStart = m.music.loopStart ?? 0;
        musicMeta.loopEnd   = m.music.loopEnd   ?? currentMusicBuf?.duration ?? 0;
      }

      if (m.sfx){
        await Promise.all(Object.entries(m.sfx).map(async([n,srcs])=>{
          let d=null; for(const u of srcs){ try{ d=await decode(u); break; }catch(_){} }
          if (d) buffers.set(n,d); else console.warn(`SFX '${n}' n√£o carregou`);
        }));
      }
    },

    playMusic({fade=0.5}={}){
      if (!unlocked || !currentMusicBuf || isPlaying) return;
      
      stopMusicSource();

      musicSource = ctx.createBufferSource();
      musicSource.buffer = currentMusicBuf;
      musicSource.connect(musicGain);
      
      // CONFIGURA√á√ÉO DO LOOP NATIVO
      musicSource.loop = true;
      musicSource.loopStart = musicMeta.loopStart;
      musicSource.loopEnd = musicMeta.loopEnd;
      musicSource.playbackRate.value = musicRate;
      
      // Inicia a m√∫sica a partir do ponto de pausa (ou do in√≠cio)
      const offset = musicPauseOffset % (musicMeta.loopEnd - musicMeta.loopStart);
      musicSource.start(t(), offset);
      
      musicStartTime = t() - offset / musicRate;
      musicPauseOffset = 0;
      isPlaying = true;
      
      // Fade-in no volume geral da m√∫sica
      if (fade > 0) {
        musicGain.gain.cancelScheduledValues(t());
        musicGain.gain.setValueAtTime(0, t());
        musicGain.gain.linearRampToValueAtTime(musicTargetVol, t() + fade);
      } else {
        musicGain.gain.setValueAtTime(musicTargetVol, t());
      }
    },

    pauseMusic({fade=0.25}={}){
      if (!isPlaying || !musicSource) return;

      const elapsed = (t() - musicStartTime) * musicRate;
      musicPauseOffset = elapsed;

      // Fade-out no volume geral da m√∫sica
      if (fade > 0) {
        musicGain.gain.cancelScheduledValues(t());
        musicGain.gain.setValueAtTime(musicGain.gain.value, t());
        musicGain.gain.linearRampToValueAtTime(0, t() + fade);
        setTimeout(stopMusicSource, fade * 1000);
      } else {
        musicGain.gain.setValueAtTime(0, t());
        stopMusicSource();
      }
    },

    // *** Vers√£o CORRIGIDA de setMusicRate ***
    setMusicRate(r){
      r = clamp(r, 0.2, 2.0); // <-- Novo valor m√≠nimo de 0.2
      musicRate = r;
      if (musicSource && isPlaying) {
        // Apenas ajusta a velocidade do som que j√° est√° tocando. Sem cortes!
        musicSource.playbackRate.setValueAtTime(musicRate, t());
      }
    },

    playSfx(n,{volume=1,detune=0}={}){
      if (!unlocked) return;
      const b=buffers.get(n); if(!b) return;
      const src=ctx.createBufferSource(); src.buffer=b;
      if (src.detune) src.detune.value=detune;
      const g=ctx.createGain(); g.gain.value=clamp(volume,0,1);
      src.connect(g); g.connect(sfxGain); src.start(0);
    },

    setMasterVolume(v){ masterGain.gain.setValueAtTime(clamp(v,0,1), t()); },
    setMusicVolume(v){ 
      musicTargetVol = clamp(v,0,1); 
      musicGain.gain.linearRampToValueAtTime(musicTargetVol, t()+0.05); 
    },

    handleVisibility(){
      if (document.hidden){ this._wasPlaying = isPlaying; if (isPlaying) this.pauseMusic({fade:0.2}); }
      else if (this._wasPlaying){ setTimeout(()=>this.playMusic({fade:0.3}), 120); }
      }
    };
  })();


  document.addEventListener('visibilitychange', AudioManager.handleVisibility.bind(AudioManager));

  // === PRELOAD DE √ÅUDIO ===
  (async function preloadAudio(){
    try{
      await AudioManager.preload({
        music: { src: ['./audio/music.ogg','./audio/music.mp3'], forceBuffer: true },
        sfx:   { click:['./audio/click.ogg','./audio/click.mp3'], hit:['./audio/hit.ogg','./audio/hit.mp3'] }
        });
    }catch(e){ console.warn('Preload de √°udio falhou:', e); }
    }) ();

  // === Spawn Config ===
  const CONFIG = {
    bagSize: 10,
    coffeePer10ByLevel: [
      { lvl: 1, coffee: 3 },
      { lvl: 8, coffee: 2 },
      { lvl: 15, coffee: 1 },
  ],
      lifeEvery: 15,
    maxLives: 5,
    hazardTypes: ['paper','imageIcon','request','graphic','graphic2']};
  function coffeePer10ForLevel(lvl){
    let val = 3;
    for (const step of CONFIG.coffeePer10ByLevel) if (lvl >= step.lvl) val = step.coffee;
    return val;
    }

 function showMenu() { 
  menu.back.style.display = 'flex'; 
  document.body.classList.add('none');           // <‚Äî
}
function hideMenu() { 
  menu.back.style.display = 'none'; 
  document.body.classList.remove('block');        // <‚Äî
}

  // START ‚Äî desbloqueia e inicia m√∫sica
  menu.start.onclick = async () => {
    await AudioManager.unlock();
    AudioManager.playMusic({fade:0.6});
    AudioManager.playSfx('click',{volume:0.8});
    hideMenu();
    reset();
    start();
  };

  // INSTRU√á√ïES
  menu.instr.onclick = () => {
    menu.instrText.style.display =
      menu.instrText.style.display === 'none' ? 'block' : 'none';
  };

  // --- Layout ---
  const HUD_TOP = 84;
  const HUD_BOTTOM = 72;
  const PLAY_Y_MIN = HUD_TOP + 8;
  const PLAY_Y_MAX = H - HUD_BOTTOM;

  // Reiniciar a partir da tela HTML
  go.restart.onclick = ()=>{ reset(); start(); };

  function byId(id){ return document.getElementById(id); }

  function fit(){ const s=Math.min(innerWidth/W, innerHeight/H); cvs.style.width=W*s+'px'; cvs.style.height=H*s+'px'; }
  addEventListener('resize', fit); fit();

  // Velocidade do jogador
  const PLAYER_BASE_SPEED = 4;
  const PLAYER_LEVEL_MULT = 0.05;

  // --- Sprites externos (tolerante a falhas) ---
  const sprites = {};
  const spritePath = "./img/";
  function loadImage(name, file) {
    return new Promise((resolve) => {
      const img = new Image();
      img.src = spritePath + file;
      img.onload = async () => { try{ if (img.decode) await img.decode(); }catch(_){} sprites[name] = img; resolve(); };
      img.onerror = () => { console.warn('Falha ao carregar sprite:', file); resolve(); };
    });
  }
  const imageFiles = [
    ["editor", "editor.png"],
    ["designer", "designer.png"],
    ["coffee", "coffee.png"],
    ["paper", "destaque.png"],
    ["imageIcon", "foto.png"],
    ["request", "mapa.png"],
    ["graphic", "grafico1.png"],
    ["ferias","ferias.png"],
    ["logo", "logo.png"],
    ["gameover", "gameover.png"],
    ["graphic2", "pizza.png"],
    ["pizza", "salario.png"],
    ["heart", "vida.png"]
  ];
 
  function drawSprite(name,x,y,w,h){
    const img = sprites[name];
    if(!img) return;
    if (w&&h) ctx.drawImage(img,x,y,w,h);
    else ctx.drawImage(img,x,y); }

  const rand=(a,b)=>Math.random()*(b-a)+a;
  const clamp2=(v,a,b)=>Math.max(a,Math.min(b,v));
 
  function rect(A,B){
    return !(A.x+A.w<B.x||B.x+B.w<A.x||A.y+A.h<B.y||B.y+B.h<A.y)
  }

  const state = {
    running:false, gameOver:false, t:0, score:0, coffee:0, lives:3, level:1,
    player:{x:W/2-24,y:H-90,w:48,h:48,vx:1,dir:1},
    editor:{ x:W/2-24, y:PLAY_Y_MIN, w:48, h:48, vx:3 },
    blinkTime: 0,
    blinkDuration: 10,
    items:[],
    totalSpawns: 0
  };

  let spawnBag = [];
  let lifeCounter = 0;

  // TIMER
  const storedBest = +localStorage.getItem('best_survival_ms') || 0;
  const timer = { accum: 0, start: 0, running: false, best: storedBest };
  function timerStart(){ timer.start = performance.now(); timer.running = true; }
  function timerPause(){ if (!timer.running) return; timer.accum += performance.now() - timer.start; timer.running = false; }
  function timerResume(){ if (timer.running) return; timer.start = performance.now(); timer.running = true; }
  function timerReset(){ timer.accum = 0; timer.running = false; timer.start = 0; }
  function getElapsedMs(){ return timer.accum + (timer.running ? performance.now() - timer.start : 0); }
  function fmtClock(ms, withCs=false){
    ms = Math.max(0, Math.floor(ms));
    const m = Math.floor(ms/60000);
    const s = Math.floor((ms%60000)/1000);
    const base = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    if (!withCs) return base;
    const cs = Math.floor((ms%1000)/10);
    return `${base}.${String(cs).padStart(2,'0')}`;
  }

  const speedMult = ()=> 1 + Math.floor(state.coffee/3)*0.05;
   function drawBg(){ ctx.fillStyle='#d9bd93'; ctx.fillRect(0,0,W,H); }

  function drawHUD(){
    ctx.font = '24px monospace';
    ctx.fillStyle = '#2b2a27';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    for(let i=0;i<state.lives;i++){
      const totalW = state.lives*20 + (state.lives-1)*10;
      const x = W/2 - totalW/2 + i*30;
      const y = H-40;
      drawSprite('heart', x, y, 20, 20);
    }
    drawSprite('coffee', 16, 40, 48, 48);
    ctx.fillText('x '+state.coffee, 86, 52);
    ctx.font = '20px monospace';
    ctx.fillText(String(state.score).padStart(4,'0'), 86, 74);
    ctx.font = '24px monospace';
    ctx.textAlign = 'right';
    ctx.fillText(fmtClock(getElapsedMs(), false), W-24, 52);
  }

function drawStart(){ ctx.fillStyle='rgba(0,0,0,.25)'; ctx.fillRect(0,0,W,H); }
function draw(){
    ctx.clearRect(0,0,W,H);
    drawBg();
    ctx.save(); ctx.globalAlpha=0.08; ctx.fillStyle='#000'; ctx.font='80px monospace'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('LVL '+state.level, W/2, H/2); ctx.restore();
    drawSprite('editor', state.editor.x, state.editor.y, 48, 48);
    drawSprite('designer', state.player.x, state.player.y, 48, 48);
    for(const it of state.items){ drawSprite(it.type, it.x, it.y, 48, 48); }
     if (state.blinkTime > 0) {
    ctx.save();
    ctx.globalAlpha = 0.5; // Transpar√™ncia do efeito (ajuste este valor)
    ctx.fillStyle = '#fff'; // Cor do piscar
    ctx.fillRect(state.player.x, state.player.y, state.player.w, state.player.h);
    ctx.restore();
    state.blinkTime--; // Diminui o contador
  }
    drawHUD();
  }
  function reset(){
    state.running=false; state.gameOver=false; state.t=0;
    state.score=0; state.coffee=0; state.level=1; state.lives=3;
    state.player.x=W/2-24; state.player.dir=1; state.player.vx=1;
    state.editor.x=W/2-24; state.editor.vx=3;
    state.items.length=0; hideGameOverHTML();
    state.totalSpawns = 0;
    timerReset();
    spawnBag.length = 0;
    lifeCounter = 0;
    draw(0); drawStart();
  }

  function refillSpawnBag(){
    const bagSize = CONFIG.bagSize;
    const coffees = Math.min(coffeePer10ForLevel(state.level), bagSize);
    const hazards = Math.max(0, bagSize - coffees);
    spawnBag.length = 0;
    for (let i = 0; i < coffees; i++) spawnBag.push('coffee');
    for (let i = 0; i < hazards; i++) {
      const t = CONFIG.hazardTypes[i % CONFIG.hazardTypes.length];
      spawnBag.push(t);
    }
    for (let i = spawnBag.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [spawnBag[i], spawnBag[j]] = [spawnBag[j], spawnBag[i]];
    }
  }

  function nextSpawnType(){
    if (spawnBag.length === 0) refillSpawnBag();
    let type = spawnBag.pop();
    if (CONFIG.lifeEvery > 0) {
      lifeCounter++;
      if (lifeCounter >= CONFIG.lifeEvery) {
        if (type === 'coffee') {
          const hazardIdx = spawnBag.findIndex(t => t !== 'coffee');
          if (hazardIdx !== -1) { const hazard = spawnBag[hazardIdx]; spawnBag[hazardIdx] = 'coffee'; type = hazard; }
        }
        type = 'pizza';
        lifeCounter = 0;
      }
    }
    return type;
  }

  function spawn(){
    const type = nextSpawnType();
    const x = clamp2(state.editor.x+24+rand(-60,60), 16, W-16-48);
    const y = state.editor.y+40;
    const baseVY = rand(2.2,4.2) + state.level*0.2;
    state.items.push({ x, y, w:48, h:48, vy:baseVY, type, sway:rand(-0.6,0.6) });
    state.totalSpawns++;
  }

  // Clique/Toque no canvas: inverte dire√ß√£o
  cvs.addEventListener('pointerdown', ()=>{
    if (!state.gameOver) state.player.dir *= -1; });

  function start(){
    if(state.gameOver) reset();
    state.running = true;
    document.getElementById('pauseBtn').textContent = '‚è∏Ô∏è Pause';
    AudioManager.playMusic({fade:0.6});
    timerStart();
    loop();
  }

  function togglePause(){
    state.running = !state.running;
    if (state.running){
      document.getElementById('menuStartBtn').textContent = '‚è∏Ô∏é Pausar';
      document.getElementById('pauseBtn').textContent = '‚è∏Ô∏è Pause';
      AudioManager.playMusic({fade:0.3});
      timerResume();
      loop();
    } else {
      document.getElementById('menuStartBtn').textContent = '‚ñ∂Ô∏è Continuar';
      document.getElementById('pauseBtn').textContent = '‚ñ∂Ô∏è Continuar';
      AudioManager.pauseMusic({fade:0.2});
      timerPause();
    }
  }

  
  ui.reset.onclick=reset;

  let muted = false;
  ui.mute.onclick=()=> {
    muted = !muted;
    if (muted) { AudioManager.setMasterVolume?.(0); ui.mute.textContent = 'üîá'; }
    else { AudioManager.setMasterVolume?.(1); ui.mute.textContent = 'üîà'; }
  };

  const pauseBtn = document.getElementById('pauseBtn');
  pauseBtn.onclick = togglePause;

  function loop(){ if(!state.running) return;
                    requestAnimationFrame(loop); update(); draw(); }

  // ===== M√∫sica acelera 0.1x a cada 2 n√≠veis (come√ßa lenta) =====
  let lastAppliedRate = MUSIC_SPEED.BASE;
  function rateForLevel(lvl){
    const steps = Math.floor(Math.max(1, lvl - 1) / MUSIC_SPEED.LEVELS_PER_STEP);
    return clamp(MUSIC_SPEED.BASE + steps * MUSIC_SPEED.STEP, MUSIC_SPEED.MIN, MUSIC_SPEED.MAX);
  }

  function update(){
    state.t++;
    state.level = 1 + Math.floor(state.coffee/3);
    // A cada n√≠vel, a m√∫sica acelera um pouco
    const desiredRate = MUSIC_SPEED.BASE + (state.level - 1) * MUSIC_SPEED.STEP;
    AudioManager.setMusicRate(clamp(desiredRate, MUSIC_SPEED.MIN, MUSIC_SPEED.MAX));

    state.editor.x += state.editor.vx * speedMult();
    if(state.editor.x<16 || state.editor.x>W-16-state.editor.w){
      state.editor.vx*=-1; state.editor.x=clamp2(state.editor.x,16,W-16-state.editor.w);
    }

    const spawnRate = Math.max(24, (80 - state.level*5) / speedMult());
    if(state.t % Math.floor(spawnRate) === 0) spawn();

    const p = state.player;
    p.vx = p.dir;
    const v = PLAYER_BASE_SPEED * (1 + (state.level - 1) * PLAYER_LEVEL_MULT);
    p.x += p.vx * v;

    if (p.x <= 16){ p.x = 16; p.dir = 1; }
    else if (p.x >= W-16-p.w){ p.x = W-16-p.w; p.dir = -1; }

    for(const it of state.items){ it.x += it.sway * speedMult()*0.6; it.y += it.vy * speedMult(); }

   for(let i=state.items.length-1;i>=0;i--){
    const it=state.items[i];
    if(it.y>H+60){ state.items.splice(i,1); continue; }
    if(rect({x:p.x,y:p.y,w:p.w,h:p.h},{x:it.x,y:it.y,w:it.h,h:it.h})){
      state.items.splice(i,1);
      if (it.type === 'coffee'){ 
        state.coffee++; 
        state.score += 5; 
        AudioManager.playSfx('click',{volume:0.8});
        state.blinkTime = state.blinkDuration; // Ativa o piscar
      }
      else if (it.type === 'pizza'){
        if (state.lives < CONFIG.maxLives) state.lives++; else state.score += 10;
        AudioManager.playSfx('click',{volume:0.8});
        state.blinkTime = state.blinkDuration; // Ativa o piscar
      } else {
        state.lives--; 
        AudioManager.playSfx('hit',{volume:1.0});
        if (state.lives <= 0) { gameOver(); break; }
      }
    }
    }      
}

  function gameOver(){
    state.running = false;
    state.gameOver = true;
    AudioManager.pauseMusic({fade:0.2});
    timerPause();
    const elapsed = getElapsedMs();
    if (elapsed > timer.best){ timer.best = elapsed; localStorage.setItem('best_survival_ms', String(timer.best)); }
    const goTimeEl = document.getElementById('goTime');
    const goBestEl = document.getElementById('goBest');
    if (goTimeEl) goTimeEl.textContent  = 'Voc√™ sobreviveu por ' + fmtClock(elapsed, true);
    if (goBestEl) goBestEl.textContent  = 'Melhor tempo: ' + fmtClock(timer.best, true);
    showGameOverHTML();
  }

 
  // Game Over (HTML) j√° √© usado; esta vers√£o canvas n√£o √© necess√°ria agora

  // Clique no canvas no GO para reiniciar (fallback)
  cvs.addEventListener('pointerdown', (e) => {
    if (!state.gameOver) return;
    reset(); start();
  });
document.addEventListener('DOMContentLoaded', () => {
  Promise.all(imageFiles.map(([n, f]) => loadImage(n, f))).then(() => {
    reset();
    draw();
    showMenu();
  });
  });
})();
 </script>
</body>
</html>








