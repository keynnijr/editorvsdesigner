<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Designer vs Editor ‚Äî Mobile 9:16 (v3)</title>
  <style>
    /* --- MENU PRINCIPAL --- */
    #menuBackdrop {
      position: fixed; inset: 0;
      display: flex; align-items: center; justify-content: center;
      background: rgba(0,0,0,.65); z-index: 9999;
    }
    #menuPanel {
      background: #f7d0a4; color: #2b2a27;
      width: min(520px, 86vw);
      border: 4px solid #4b3a2a; border-radius: 12px;
      padding: 20px; text-align: center;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    #menuLogo { max-width: 80%; margin-bottom: 20px; }
    .menu-buttons { display: flex; flex-direction: column; gap: 10px; }
    .menu-buttons button {
      padding: 12px; border: 2px solid #5a5348; border-radius: 10px;
      background: #1e1d1b; color: #fff; cursor: pointer; font-size: 18px;
    }
    .menu-buttons button:active { transform: translateY(1px); }

    :root { --bg:#2b2a27; --panel:#1e1d1b; }
    html,body{height:100%;margin:0;background:var(--bg);font-family:system-ui,Segoe UI,Roboto,Arial;overflow:hidden}
    .wrap{display:grid;place-items:center;height:100%;padding:0}
    canvas{image-rendering: pixelated; image-rendering: crisp-edges; background:#e3cda1; outline:3px solid #4b3a2a; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .bar{display:flex;gap:8px;align-items:center;justify-content:center;color:#fff;opacity:.9;margin-top:6px}
    .btn{background:var(--panel);border:2px solid #5a5348;border-radius:10px;padding:8px 12px;cursor:pointer}
    .btn:active{transform:translateY(1px)}
    .touch{position:fixed;left:0;right:0;bottom:14px;display:flex;justify-content:center;gap:16px;pointer-events:auto}
    .tbtn{font-size:22px;width:64px;height:64px;border-radius:12px}
    /* --- Game Over HTML --- */
    #goBackdrop{
      position:fixed; inset:0; display:none;
      align-items:center; justify-content:center;
      background:rgba(0,0,0,.65); z-index:9999;
    }
    #goPanel{
      background:#f7d0a4; color:#2b2a27;
      width:min(520px,86vw); border:4px solid #4b3a2a;
      border-radius:12px; padding:20px; text-align:center;
      box-shadow:0 10px 30px rgba(0,0,0,.35);
    }
    #goPanel img{ max-width:100%; height:auto; display:block; margin:0 auto 12px; }
    #goPanel p{ margin:0 0 12px; font:16px/1.4 monospace; }
    #goPanel button{
      padding:10px 16px; border:2px solid #5a5348; border-radius:10px;
      background:#1e1d1b; color:#fff; cursor:pointer;
    }
    #goPanel button:active{ transform:translateY(1px); }

    @media (pointer:fine){ .touch{display:none} }
  </style>
</head>
<body>
  <!-- MENU PRINCIPAL -->
  <div id="menuBackdrop">
    <div id="menuPanel">
      <img src="./img/logo.png" alt="Logo do jogo" id="menuLogo" />
      <div class="menu-buttons">
        <button id="menuStartBtn">‚ñ∂Ô∏è START</button>
        <button id="menuInstrBtn">üìú INSTRU√á√ïES</button>
      </div>
      <p id="menuInstrText" style="display:none; margin-top: 16px; font-size: 16px; line-height: 1.4;">
        üìú <b>Como jogar:</b><br>
        Clique na tela para mudar a dire√ß√£o do designer e desviar dos objetos.<br>
        Colete caf√©s para ganhar pontos.<br>
        Evite tudo o que n√£o for caf√©!
      </p>
    </div>
  </div>

  <div class="wrap">
    <canvas id="game" width="540" height="960" aria-label="Designer vs Editor (mobile)"></canvas>
    <div class="bar">
      <button id="startBtn" class="btn">‚ñ∂Ô∏è Jogar</button>
      <button id="muteBtn" class="btn">üîà</button>
      <button id="resetBtn" class="btn">‚ü≤</button>
      <!-- TELA DE GAME OVER (HTML) -->
      <div id="goBackdrop" aria-hidden="true">
        <div id="goPanel">
          <img src="./img/gameover.png" alt="Game Over" />
          <h2 style="font-size: 32px; font-weight: bold; margin-bottom: 10px;">
            VOC√ä SOFREU UM BURNOUT!!!
          </h2>
          <p style="font-size: 24px;">Tire 1 ano sab√°tico e tente novamente.</p>
          <p id="goTime" style="font-size:20px; margin:8px 0 0 0;"></p>
          <p id="goBest" style="font-size:14px; opacity:.8;"></p>
          <button id="restartBtn">Reiniciar</button>
        </div>
      </div>
    </div>
  </div>

  <div class="touch">
    <button class="btn tbtn" id="left">‚¨Ö</button>
    <button class="btn tbtn" id="right">‚û°</button>
  </div>

  <button id="pauseBtn" class="btn" style="
    position: fixed;
    left: 18px;
    bottom: 18px;
    z-index: 10001;
    font-size: 22px;
    padding: 12px 18px;
    color: #fff;">‚è∏Ô∏è Pause</button>

<script>
(() => {
  const W = 540, H = 960;
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d');
  const ui = { start:byId('startBtn'), reset:byId('resetBtn'), mute:byId('muteBtn'), left:byId('left'), right:byId('right') };

  // HTML de Game Over
  const go = { back: byId('goBackdrop'), restart: byId('restartBtn') };
  function showGameOverHTML(){ go.back.style.display = 'flex'; go.back.setAttribute('aria-hidden','false'); }
  function hideGameOverHTML(){ go.back.style.display = 'none'; go.back.setAttribute('aria-hidden','true'); }

  // --- MENU PRINCIPAL ---
  const menu = {
    back: document.getElementById('menuBackdrop'),
    start: document.getElementById('menuStartBtn'),
    instr: document.getElementById('menuInstrBtn'),
    instrText: document.getElementById('menuInstrText')
  };

  // === AUDIO MANAGER ‚Äî scheduler + equal-power crossfade + velocidade din√¢mica ===
  const AudioManager = (() => {
    // Velocidade din√¢mica
    let musicRate = 1; // velocidade atual
    const BASE_RATE = 0.8;          // ‚áê velocidade inicial (slow motion)
    const RATE_STEP = 0.1;          // ‚áê +0.1x por passo
    const LEVELS_PER_STEP = 2;      // ‚áê 1 passo a cada 2 n√≠veis
    const MIN_RATE = 0.5, MAX_RATE = 2.0;

    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    // Segmentos ativos de m√∫sica (para matar e evitar sobreposi√ß√£o)
    const activeSeg = new Set();
    function killSegments() {
      for (const node of Array.from(activeSeg)) {
        try { node.stop(0); } catch(_) {}
      }
      activeSeg.clear();
    }

    // WebAudio
    let ctx=null, unlocked=false, masterGain, musicGain, sfxGain;
    let useMediaElement=false, mediaEl=null, mediaElSrcs=[];
    let musicTargetVol = 0.8;
    const buffers=new Map(), sfxConcurrentLimit=16, activeSfx=new Set();

    // meta do loop
    let musicMeta={loopStart:0, loopEnd:null, loopStartSamples:null, loopEndSamples:null, epsilonSec:0};
    // engine
    let currentMusicBuf=null;
    let musicStartTime=0, musicPauseOffset=0;
    let playing=false;

    // scheduler
    const LOOKAHEAD_SEC = 0.025;
    const SCHEDULE_AHEAD_SEC = 0.30;
    let schedId=null;
    let nextWhen=0, nextOffset=0, nextLen=0, loopLen=0, loopStart=0, loopEnd=0;

    // crossfade
    let CROSSFADE_SEC = 0.02;

    // curva equal-power
    function makeEqualPowerCurves(samples=128){
      const fadeIn = new Float32Array(samples), fadeOut= new Float32Array(samples);
      for(let i=0;i<samples;i++){ const x=i/(samples-1); fadeIn[i]=Math.sin(x*Math.PI/2); fadeOut[i]=Math.cos(x*Math.PI/2); }
      return {fadeIn, fadeOut};
    }
    const curves = makeEqualPowerCurves(128);

    function ensureContext(){
      if(!ctx){
        ctx = new (window.AudioContext || window.webkitAudioContext)();

        // crie TODOS os n√≥s
        masterGain = ctx.createGain();
        musicGain  = ctx.createGain();
        sfxGain    = ctx.createGain();

        // volumes iniciais (0‚Äì1)
        masterGain.gain.value = 1;
        musicGain.gain.value  = musicTargetVol;
        sfxGain.gain.value    = 1;

        // conex√µes
        musicGain.connect(masterGain);
        sfxGain.connect(masterGain);
        masterGain.connect(ctx.destination);
      }
    }
    async function fetchAB(u){ const r=await fetch(u); if(!r.ok) throw new Error('Falha ao buscar '+u); return await r.arrayBuffer(); }
    async function decode(u){ ensureContext(); const ab=await fetchAB(u); return await ctx.decodeAudioData(ab); }
    function t(){ return ctx?ctx.currentTime:0; }
    function rampParam(p,v,s=0.001){ const n=t(); p.cancelScheduledValues(n); p.setValueAtTime(p.value,n); p.linearRampToValueAtTime(v,n+Math.max(0.001,s)); }
    function pick(a){ return a[0]||null; }

    function scheduleOne(when, offset, dur){
      const src = ctx.createBufferSource(); src.buffer = currentMusicBuf;
      src.playbackRate.value = musicRate;

      const g = ctx.createGain(); src.connect(g); g.connect(musicGain);

      // dura√ß√£o em tempo "de parede" = segundos do buffer / rate
      const segWall = Math.max(0.001, dur / musicRate);
      const fi = Math.min(CROSSFADE_SEC, segWall * 0.5);
      const fo = Math.min(CROSSFADE_SEC, segWall * 0.5);

      g.gain.setValueAtTime(0, when);
      g.gain.setValueCurveAtTime(curves.fadeIn, when, fi);
      g.gain.setValueAtTime(1, when+fi);
      g.gain.setValueCurveAtTime(curves.fadeOut, when+segWall-fo, fo);

      src.start(when, offset, dur);

      activeSeg.add(src);
      src.onended = () => { activeSeg.delete(src); try{ src.disconnect(); g.disconnect(); }catch(_){} };
    }

    function stopScheduler(){ playing=false; if (schedId){ clearInterval(schedId); schedId=null; } }
    function startScheduler(){
      stopScheduler(); playing=true;
      schedId = setInterval(() => {
        if(!playing || !currentMusicBuf) return;
        const now=t();
        while (nextWhen < now + SCHEDULE_AHEAD_SEC) {
          scheduleOne(nextWhen, nextOffset, nextLen);
          const segWall = Math.max(0.001, nextLen / musicRate);
          nextWhen   = nextWhen + segWall - CROSSFADE_SEC;
          nextOffset = loopStart;
          nextLen    = loopLen;
        }
      }, LOOKAHEAD_SEC*1000);
    }

    // badge de diagn√≥stico
    function mountBadge(){
      if (document.getElementById('audio-badge')) return;
      const b=document.createElement('div'); b.id='audio-badge';
      b.style.cssText='position:fixed;right:8px;bottom:8px;background:#111c;border:1px solid #fff3;color:#fff;padding:6px 8px;border-radius:6px;font:12px/1.2 monospace;z-index:99999';
      document.body.appendChild(b);
      updateBadge();
    }
    function updateBadge(){
      const el=document.getElementById('audio-badge'); if(!el) return;
      el.textContent = `buf:${!!currentMusicBuf} media:${useMediaElement} loop:[${(loopStart??0).toFixed(3)}‚Äì${(loopEnd??0).toFixed(3)}] rate:${musicRate.toFixed(2)} cf:${(CROSSFADE_SEC*1000)|0}ms`;
    }

    let wasPlayingBeforeHide = false;

    return {
      async unlock(){ ensureContext(); if(ctx.state==='suspended'){ try{ await ctx.resume(); }catch{} } unlocked=true; },

      async preload(m={}){
        ensureContext();
        const wantBuffer = !!m.music?.forceBuffer;
        if(m.music?.src?.length){
          let dec=null, tried=[];
          for(const u of m.music.src){
            try{ dec=await decode(u); tried.push([u,'ok']); break; }
            catch(e){ tried.push([u,'fail']); }
          }
          if(dec){
            currentMusicBuf=dec; useMediaElement=false;
          }else{
            if (wantBuffer){
              console.error('[AudioManager] Nenhum formato decodificou, e forceBuffer=true. Verifique codecs/paths.', tried);
              throw new Error('forceBuffer=true mas nenhum src decodificou.');
            }
            useMediaElement=true; mediaElSrcs=m.music.src;
            mediaEl=new Audio(); mediaEl.loop=true; mediaEl.preload='auto'; mediaEl.src=pick(mediaElSrcs);
            console.warn('[AudioManager] Caindo em <audio>. Crossfade n√£o ser√° aplicado.', tried);
          }

          musicMeta.loopStartSamples = m.music.loopStartSamples ?? null;
          musicMeta.loopEndSamples   = m.music.loopEndSamples   ?? null;
          musicMeta.loopStart        = m.music.loopStart ?? 0;
          musicMeta.loopEnd          = m.music.loopEnd   ?? null;

          if (currentMusicBuf){
            const sr=currentMusicBuf.sampleRate||44100;
            musicMeta.epsilonSec = 1/sr;
            if (musicMeta.loopStartSamples != null) musicMeta.loopStart = musicMeta.loopStartSamples/sr;
            if (musicMeta.loopEndSamples   != null) musicMeta.loopEnd   = musicMeta.loopEndSamples/sr;
            if (musicMeta.loopEnd == null) musicMeta.loopEnd = currentMusicBuf.duration - musicMeta.epsilonSec;
            else musicMeta.loopEnd = Math.max(0, musicMeta.loopEnd - musicMeta.epsilonSec);
            musicMeta.loopStart = Math.max(0, Math.min(musicMeta.loopStart, currentMusicBuf.duration - 0.001));
            musicMeta.loopEnd   = Math.max(musicMeta.loopStart + 0.001, Math.min(musicMeta.loopEnd, currentMusicBuf.duration));
          }
        }

        if(m.sfx){
          await Promise.all(Object.entries(m.sfx).map(async([n,srcs])=>{
            let d=null; for(const u of srcs){ try{ d=await decode(u); break; }catch(e){} }
            if(d) buffers.set(n,d); else console.warn(`SFX '${n}' n√£o carregou`);
          }));
        }

        mountBadge(); updateBadge();
        window.AudioDiag = () => ({
          unlocked, usingMediaElement:useMediaElement, hasBuffer:!!currentMusicBuf,
          loopStart: musicMeta.loopStart, loopEnd: musicMeta.loopEnd,
          bufferDuration: currentMusicBuf?.duration, sampleRate: currentMusicBuf?.sampleRate,
          ctxState: ctx?.state
        });
        console.log('[AudioManager] state:', window.AudioDiag());
      },

      playMusic({fade=0.5}={}){
        if(!unlocked){ console.warn('chame unlock() ap√≥s gesto'); return; }

        // Fallback <audio>
        if (useMediaElement){
          if (!mediaEl) return;
          mediaEl.playbackRate = musicRate;
          if (fade > 0){
            const target = musicTargetVol;
            mediaEl.volume = 0;
            mediaEl.play().catch(()=>{});
            const start = performance.now(), dur = fade*1000;
            const iv = setInterval(()=> {
              const p = Math.min(1, (performance.now()-start)/dur);
              mediaEl.volume = target * p;
              if (p>=1) clearInterval(iv);
            }, 33);
          } else {
            mediaEl.volume = musicTargetVol;
            mediaEl.play().catch(()=>{});
          }
          return;
        }

        if (!currentMusicBuf) return;

        // inicia limpo
        stopScheduler();
        killSegments();

        loopStart = musicMeta.loopStart;
        loopEnd   = musicMeta.loopEnd ?? currentMusicBuf.duration;
        loopLen   = Math.max(0.001, loopEnd - loopStart);

        let offset = musicPauseOffset ? (musicPauseOffset % loopLen) + loopStart : loopStart;
        if (offset < loopStart || offset >= loopEnd) offset = loopStart;

        nextOffset = offset;
        nextLen    = Math.max(0.001, loopEnd - offset);
        nextWhen   = t() + 0.02;

        if (fade > 0) {
          musicGain.gain.setValueAtTime(0, t());
          musicGain.gain.linearRampToValueAtTime(musicTargetVol, t() + fade);
        } else {
          musicGain.gain.setValueAtTime(musicTargetVol, t());
        }

        musicStartTime = t() - (offset - loopStart);
        musicPauseOffset = 0;

        scheduleOne(nextWhen, nextOffset, nextLen);
        const segWall = Math.max(0.001, nextLen / musicRate);
        nextWhen   = nextWhen + segWall - CROSSFADE_SEC;
        nextOffset = loopStart;
        nextLen    = loopLen;

        startScheduler();
        updateBadge();
      },

      pauseMusic({fade=0.25}={}){
        // Fallback <audio>
        if (useMediaElement){
          if (!mediaEl) return;
          if (fade > 0){
            const start = mediaEl.volume, target = 0, dur = fade*1000;
            const t0 = performance.now();
            const iv = setInterval(()=> {
              const p = Math.min(1, (performance.now()-t0)/dur);
              mediaEl.volume = start + (target-start)*p;
              if (p>=1){ clearInterval(iv); mediaEl.pause(); mediaEl.volume = start; }
            }, 33);
          } else {
            mediaEl.pause();
          }
          return;
        }

        if (!currentMusicBuf) return;

        const elapsed = t() - musicStartTime;
        // deslocamento dentro do loop em segundos de BUFFER (compensa rate)
        const inner = ((elapsed * musicRate) % loopLen + loopLen) % loopLen;
        musicPauseOffset = inner;

        if (fade > 0) {
          musicGain.gain.cancelScheduledValues(t());
          musicGain.gain.setValueAtTime(musicGain.gain.value, t());
          musicGain.gain.linearRampToValueAtTime(0, t() + fade);
          setTimeout(()=>{ stopScheduler(); killSegments(); }, Math.max(1, fade*1000));
        } else {
          musicGain.gain.setValueAtTime(0, t());
          stopScheduler();
          killSegments();
        }
      },

      setMusicRate(r){
        r = clamp(r, MIN_RATE, MAX_RATE);

        // fallback <audio>
        if (useMediaElement){
          musicRate = r;
          if (mediaEl) mediaEl.playbackRate = r;
          updateBadge();
          return;
        }

        if (!currentMusicBuf){ musicRate = r; return; }

        // calcula posi√ß√£o musical com a taxa anterior
        const now = t();
        const elapsed = now - musicStartTime;
        const inner = ((elapsed * musicRate) % loopLen + loopLen) % loopLen;
        musicPauseOffset = inner;

        musicRate = r;

        // reinicia limpo no mesmo ponto, com micro‚Äëfade
        stopScheduler();
        killSegments();
        this.playMusic({fade:0.05});
        updateBadge();
      },

      async crossfadeTo(srcs,fade=1.0,loop={}){
        ensureContext();
        let nb=null; for(const u of srcs){ try{ nb=await decode(u); break; }catch(e){} }
        if(!nb){
          this.pauseMusic({fade});
          useMediaElement=true; mediaEl=new Audio(); mediaEl.loop=true; mediaEl.preload='auto'; mediaEl.src=pick(srcs);
          mediaEl.volume=0; mediaEl.playbackRate = musicRate; mediaEl.play().catch(()=>{});
          const target=musicTargetVol, step=1/30; let x=0; const iv=setInterval(()=>{ x+=step; mediaEl.volume=Math.min(target,x/fade*target); if(x>=fade) clearInterval(iv); },33);
          return;
        }
        this.pauseMusic({fade});
        setTimeout(()=>{
          currentMusicBuf = nb;
          const sr = nb.sampleRate||44100;
          musicMeta.loopStart = loop.loopStart ?? 0;
          musicMeta.loopEnd   = loop.loopEnd ?? (nb.duration - 1/sr);
          this.playMusic({fade});
          updateBadge();
        }, Math.max(10, fade*1000));
      },

      playSfx(n,{volume=1,detune=0}={}){
        if(!unlocked) return;
        const b=buffers.get(n); if(!b) return;
        if(activeSfx.size>=sfxConcurrentLimit) return;
        const src=ctx.createBufferSource(); src.buffer=b;
        if(src.detune) src.detune.value=detune;
        const g=ctx.createGain(); g.gain.value=Math.max(0,Math.min(1,volume));
        src.connect(g); g.connect(sfxGain); src.start(0);
        activeSfx.add(src); src.onended=()=>activeSfx.delete(src);
      },

      setMasterVolume(v){ rampParam(masterGain.gain,v,0.05); },
      setMusicVolume(v){
        musicTargetVol = clamp(v,0,1);
        const now = t();
        musicGain.gain.cancelScheduledValues(now);
        musicGain.gain.setValueAtTime(musicGain.gain.value, now);
        musicGain.gain.linearRampToValueAtTime(musicTargetVol, now + 0.05);
      },

      setSfxVolume(v){ rampParam(sfxGain.gain,clamp(v,0,1),0.01); },

      handleVisibility(){
        if (document.hidden){
          wasPlayingBeforeHide = playing;
          this.pauseMusic({fade:0.2});
        } else {
          if (wasPlayingBeforeHide){
            setTimeout(() => this.playMusic({fade:0.3}), 100);
          }
        }
      },

      // helpers expostos (opcional)
      _diag(){ return {playing, musicRate, loopStart, loopEnd, loopLen}; }
    };
  })();
  // === /AUDIO MANAGER ===

  // Registra visibilidade com bind para manter o this correto
  document.addEventListener('visibilitychange', AudioManager.handleVisibility.bind(AudioManager));

  // === PRELOAD DE √ÅUDIO (forceBuffer:true) ===
  (async function preloadAudio(){
    try{
      await AudioManager.preload({
        music: {
          src: ['./audio/music.ogg','./audio/music.mp3'],
          forceBuffer: true
        },
        sfx: {
          click: ['./audio/click.ogg','./audio/click.mp3'],
          hit:   ['./audio/hit.ogg','./audio/hit.mp3']
        }
      });
    }catch(e){ console.warn('Preload de √°udio falhou:', e); }
  })();
  // === /PRELOAD DE √ÅUDIO ===

  // === Spawn Config ===
  const CONFIG = {
    bagSize: 10,
    coffeePer10ByLevel: [
      { lvl: 1, coffee: 3 },
      { lvl: 8, coffee: 2 },
      { lvl: 15, coffee: 1 },
    ],
    lifeEvery: 15,
    maxLives: 5,
    hazardTypes: ['paper','imageIcon','request','graphic','graphic2']
  };
  function coffeePer10ForLevel(lvl){
    let val = 3;
    for (const step of CONFIG.coffeePer10ByLevel) if (lvl >= step.lvl) val = step.coffee;
    return val;
  }

  // Mostrar/Ocultar menu
  function showMenu() { menu.back.style.display = 'flex'; }
  function hideMenu() { menu.back.style.display = 'none'; }

  // START ‚Äî desbloqueia e inicia m√∫sica
  menu.start.onclick = async () => {
    await AudioManager.unlock();
    AudioManager.playMusic({fade:0.6});
    AudioManager.playSfx('click',{volume:0.8});
    hideMenu();
    reset();
    start();
  };

  // INSTRU√á√ïES
  menu.instr.onclick = () => {
    menu.instrText.style.display =
      menu.instrText.style.display === 'none' ? 'block' : 'none';
  };

  // --- Layout ---
  const HUD_TOP = 84;
  const HUD_BOTTOM = 72;
  const PLAY_Y_MIN = HUD_TOP + 8;
  const PLAY_Y_MAX = H - HUD_BOTTOM;
  const logoImg = new Image(); logoImg.src = './img/logo.png';
  const goTimeEl = document.getElementById('goTime');
  const goBestEl = document.getElementById('goBest');

  // Reiniciar a partir da tela HTML
  go.restart.onclick = ()=>{ reset(); start(); };

  function byId(id){ return document.getElementById(id); }

  function fit(){ const s=Math.min(innerWidth/W, innerHeight/H); cvs.style.width=W*s+'px'; cvs.style.height=H*s+'px'; }
  addEventListener('resize', fit); fit();

  // Velocidade do jogador
  const PLAYER_BASE_SPEED = 6;
  const PLAYER_LEVEL_MULT = 0.12;

  // --- Carregar sprites externos ---
  const sprites = {};
  const spritePath = "./img/";
  const gameOverImg = new Image();
  gameOverImg.src = spritePath + 'gameover.png';

  let goBtn = null;

  function loadImage(name, file) {
    return new Promise((resolve) => {
      const img = new Image();
      img.src = spritePath + file;
      img.onload = async () => {
        try { if (img.decode) await img.decode(); } catch(_) {}
        sprites[name] = img;
        resolve();
      };
      img.onerror = () => {
        console.warn('Falha ao carregar', name);
        resolve();
      };
    });
  }

  // Lista de imagens usadas
  const imageFiles = [
    ["editor", "editor.png"],
    ["designer", "designer.png"],
    ["coffee", "coffee.png"],
    ["paper", "destaque.png"],
    ["imageIcon", "foto.png"],
    ["request", "mapa.png"],
    ["graphic", "grafico1.png"],
    ["ferias","ferias.png"],
    ["logo", "logo.png"],
    ["gameover", "gameover.png"],
    ["graphic2", "pizza.png"],
    ["pizza", "salario.png"],
    ["heart", "vida.png"]
  ];

  function drawSprite(name, x, y, w, h) {
    const img = sprites[name];
    if (img) {
      if (w && h) ctx.drawImage(img, x, y, w, h);
      else ctx.drawImage(img, x, y);
    }
  }

  const rand=(a,b)=>Math.random()*(b-a)+a; const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  function rect(A,B){return !(A.x+A.w<B.x||B.x+B.w<A.x||A.y+A.h<B.y||B.y+B.h<A.y)}

  const state = { 
    running:false, gameOver:false, t:0, score:0, coffee:0, lives:3, level:1,
    player:{x:W/2-24,y:H-90,w:48,h:48,vx:1,dir:1},
    editor:{ x:W/2-24, y:PLAY_Y_MIN, w:48, h:48, vx:3 },
    items:[],
    totalSpawns: 0
  };

  let spawnBag = [];
  let lifeCounter = 0;

  // TIMER DE SOBREVIV√äNCIA
  const storedBest = +localStorage.getItem('best_survival_ms') || 0;
  const timer = { accum: 0, start: 0, running: false, best: storedBest };

  function timerStart(){ timer.start = performance.now(); timer.running = true; }
  function timerPause(){ if (!timer.running) return; timer.accum += performance.now() - timer.start; timer.running = false; }
  function timerResume(){ if (timer.running) return; timer.start = performance.now(); timer.running = true; }
  function timerReset(){ timer.accum = 0; timer.running = false; timer.start = 0; }
  function getElapsedMs(){ return timer.accum + (timer.running ? performance.now() - timer.start : 0); }
  function fmtClock(ms, withCs=false){
    ms = Math.max(0, Math.floor(ms));
    const m = Math.floor(ms/60000);
    const s = Math.floor((ms%60000)/1000);
    const base = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    if (!withCs) return base;
    const cs = Math.floor((ms%1000)/10);
    return `${base}.${String(cs).padStart(2,'0')}`;
  }

  const speedMult = ()=> 1 + Math.floor(state.coffee/3)*0.15;

  function reset(){
    state.running=false; state.gameOver=false; state.t=0;
    state.score=0; state.coffee=0; state.level=1; state.lives=3;
    state.player.x=W/2-24; state.player.dir=1; state.player.vx=1;
    state.editor.x=W/2-24; state.editor.vx=3;
    state.items.length=0; goBtn=null; hideGameOverHTML();
    state.totalSpawns = 0;
    timerReset();
    spawnBag.length = 0;
    lifeCounter = 0;
    draw(0); drawStart();
  }

  function refillSpawnBag(){
    const bagSize = CONFIG.bagSize;
    const coffees = Math.min(coffeePer10ForLevel(state.level), bagSize);
    const hazards = Math.max(0, bagSize - coffees);

    spawnBag.length = 0;
    for (let i = 0; i < coffees; i++) spawnBag.push('coffee');
    for (let i = 0; i < hazards; i++) {
      const t = CONFIG.hazardTypes[i % CONFIG.hazardTypes.length];
      spawnBag.push(t);
    }

    // embaralha
    for (let i = spawnBag.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [spawnBag[i], spawnBag[j]] = [spawnBag[j], spawnBag[i]];
    }
  }

  function nextSpawnType(){
    if (spawnBag.length === 0) refillSpawnBag();

    // pega um tipo da bolsa
    let type = spawnBag.pop();

    // avan√ßa contador de vida e verifica drop
    if (CONFIG.lifeEvery > 0) {
      lifeCounter++;
      if (lifeCounter >= CONFIG.lifeEvery) {
        if (type === 'coffee') {
          const hazardIdx = spawnBag.findIndex(t => t !== 'coffee');
          if (hazardIdx !== -1) {
            const hazard = spawnBag[hazardIdx];
            spawnBag[hazardIdx] = 'coffee';
            type = hazard;
          }
        }
        type = 'pizza';
        lifeCounter = 0;
      }
    }
    return type;
  }

  function spawn(){
    const type = nextSpawnType();
    const x = clamp(state.editor.x+24+rand(-60,60), 16, W-16-48);
    const y = state.editor.y+40;
    const baseVY = rand(2.2,4.2) + state.level*0.2;
    state.items.push({ x, y, w:48, h:48, vy:baseVY, type, sway:rand(-0.6,0.6) });
    state.totalSpawns++;
  }

  const keys={left:false,right:false};

  // Clique/Toque: inverte a dire√ß√£o do designer (no canvas)
  cvs.addEventListener('pointerdown', ()=>{
    if (state.gameOver) return;
    state.player.dir *= -1;
  });

  function start(){
    if(state.gameOver) reset();
    state.running = true;
    ui.start.textContent = '‚è∏Ô∏é Pausar';
    AudioManager.playMusic({fade:0.6});  // m√∫sica entra suave
    timerStart();
    loop();
  }  

  function togglePause(){
    state.running = !state.running;
    if (state.running){
      ui.start.textContent = '‚è∏Ô∏é Pausar';
      AudioManager.playMusic({fade:0.3});
      timerResume();
      loop();
    } else {
      ui.start.textContent = '‚ñ∂Ô∏è Continuar';
      AudioManager.pauseMusic({fade:0.2});
      timerPause();
    }
  }  

  ui.start.onclick=()=>{ if(!state.running && !state.gameOver) start(); else togglePause(); };
  ui.reset.onclick=reset;

  // Mute (volume geral)
  let muted = false;
  ui.mute.onclick=()=> {
    muted = !muted;
    if (muted) { AudioManager.setMasterVolume(0); ui.mute.textContent = 'üîá'; }
    else { AudioManager.setMasterVolume(1); ui.mute.textContent = 'üîà'; }
  };

  const pauseBtn = document.getElementById('pauseBtn');
  pauseBtn.onclick = function() {
    togglePause();
    pauseBtn.textContent = state.running ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Continuar';
    pauseBtn.style.color = '#fff';
  };

  function loop(){ if(!state.running) return; requestAnimationFrame(loop); update(); draw(); }

  // ====== m√∫sica acelera 0.1x a cada 2 n√≠veis, come√ßando em BASE_RATE ======
  let lastAppliedRate = BASE_RATE;
  function rateForLevel(lvl){
    const steps = Math.floor(Math.max(1, lvl - 1) / 2); // 2 n√≠veis por passo
    return Math.max(MIN_RATE, Math.min(MAX_RATE, BASE_RATE + steps * RATE_STEP));
  }

  function update(){
    state.t++;

    // level aumenta a cada 3 caf√©s
    state.level = 1 + Math.floor(state.coffee/3);

    // aplica taxa de reprodu√ß√£o desejada
    const desiredRate = rateForLevel(state.level);
    if (Math.abs(desiredRate - lastAppliedRate) > 1e-4){
      AudioManager.setMusicRate(desiredRate);
      lastAppliedRate = desiredRate;
    }

    // Movimento do editor
    state.editor.x += state.editor.vx * speedMult();
    if(state.editor.x<16 || state.editor.x>W-16-state.editor.w){
      state.editor.vx*=-1;
      state.editor.x=clamp(state.editor.x,16,W-16-state.editor.w);
    }

    // Spawns
    const rate = Math.max(24, (80 - state.level*5) / speedMult());
    if(state.t % Math.floor(rate) === 0) spawn();

    // Jogador
    const p = state.player;
    p.vx = p.dir;
    const v = PLAYER_BASE_SPEED * (1 + (state.level - 1) * PLAYER_LEVEL_MULT);
    p.x += p.vx * v;

    // inverter nas bordas
    if (p.x <= 16){ p.x = 16; p.dir = 1; }
    else if (p.x >= W-16-p.w){ p.x = W-16-p.w; p.dir = -1; }

    // Itens
    for(const it of state.items){
      it.x += it.sway * speedMult()*0.6;
      it.y += it.vy   * speedMult();
    }

    // Colis√µes
    for(let i=state.items.length-1;i>=0;i--){ 
      const it=state.items[i]; 
      if(it.y>H+60){ state.items.splice(i,1); continue; }
      if(rect({x:p.x,y:p.y,w:p.w,h:p.h},{x:it.x,y:it.y,w:it.w,h:it.h})){
        state.items.splice(i,1); // remove antes de processar

        if (it.type === 'coffee') {
          state.coffee++; state.score += 5;
          AudioManager.playSfx('click', {volume:0.8});
        } else if (it.type === 'pizza') { // vida
          if (state.lives < CONFIG.maxLives) { state.lives++; }
          else { state.score += 10; }
          AudioManager.playSfx('click', {volume:0.8});
        } else { // hazard
          state.lives--;
          AudioManager.playSfx('hit', {volume:1.0});
          if (state.lives <= 0) { gameOver(); break; }
        }
      }
    }
  }

  function gameOver(){
    state.running = false;
    state.gameOver = true;
    AudioManager.pauseMusic({fade:0.2}); // para BGM suavemente

    timerPause();
    const elapsed = getElapsedMs();

    if (elapsed > timer.best){
      timer.best = elapsed;
      localStorage.setItem('best_survival_ms', String(timer.best));
    }

    const goTimeEl = document.getElementById('goTime');
    const goBestEl = document.getElementById('goBest');
    if (goTimeEl) goTimeEl.textContent  = 'Voc√™ sobreviveu por ' + fmtClock(elapsed, true);
    if (goBestEl) goBestEl.textContent  = 'Melhor tempo: ' + fmtClock(timer.best, true);
    
    showGameOverHTML();
  }

  function drawBg(){ ctx.fillStyle='#d9bd93'; ctx.fillRect(0,0,W,H); }

  function drawHUD(){
    ctx.font = '24px monospace';
    ctx.fillStyle = '#2b2a27';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';

    // vidas
    for(let i=0;i<state.lives;i++){
      const totalW = state.lives*20 + (state.lives-1)*10;
      const x = W/2 - totalW/2 + i*30;
      const y = H-40;
      drawSprite('heart', x, y, 20, 20);
    }
    drawSprite('coffee', 16, 40, 48, 48);
    ctx.fillText('x '+state.coffee, 86, 52);

    // Score
    ctx.font = '20px monospace';
    ctx.fillText(String(state.score).padStart(4,'0'), 86, 74);

    // Cron√¥metro
    ctx.font = '24px monospace';
    ctx.textAlign = 'right';
    ctx.fillText(fmtClock(getElapsedMs(), false), W-24, 52);
  }

  function draw(){
    ctx.clearRect(0,0,W,H);
    drawBg();
    ctx.save(); ctx.globalAlpha=0.08; ctx.fillStyle='#000'; ctx.font='80px monospace'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('LVL '+state.level, W/2, H/2); ctx.restore();
    drawSprite('editor', state.editor.x, state.editor.y, 48, 48);
    drawSprite('designer', state.player.x, state.player.y, 48, 48);
    for(const it of state.items){ drawSprite(it.type, it.x, it.y, 48, 48); }
    drawHUD();
  }

  function drawStart(){ ctx.fillStyle='rgba(0,0,0,.25)'; ctx.fillRect(0,0,W,H); }

  function wrapText(ctx, text, x, y, maxWidth, lineHeight){
    const words = text.split(' ');
    let line = '', yy = y;
    for (let i=0;i<words.length;i++){
      const test = line + (line?' ':'') + words[i];
      if (ctx.measureText(test).width > maxWidth && i>0){
        ctx.fillText(line, x, yy);
        line = words[i];
        yy += lineHeight;
      } else {
        line = test;
      }
    }
    ctx.fillText(line, x, yy);
  }

  function drawGameOver(){
    // overlay
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0,0,W,H);

    // painel central
    const panelW = Math.min(520, W * 0.8);
    const panelH = Math.min(380, H * 0.7);
    const px = (W - panelW) / 2;
    const py = (H - panelH) / 2;

    ctx.fillStyle = '#ffffff';
    ctx.fillRect(px, py, panelW, panelH);
    ctx.lineWidth = 4;
    ctx.strokeStyle = '#4b3a2a';
    ctx.strokeRect(px+2, py+2, panelW-4, panelH-4);

    // imagem
    const imgW = Math.min(panelW - 40, 320);
    const imgH = imgW * 0.5625;
    const ix = W/2 - imgW/2;
    const iy = py + 24;
    const gameOverImg = new Image(); gameOverImg.src = './img/gameover.png';
    if (gameOverImg.complete) ctx.drawImage(gameOverImg, ix, iy, imgW, imgH);

    // texto
    ctx.fillStyle = '#2b2a27';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.font = '18px monospace';
    const msg = 'Que pena. Voc√™ n√£o performou o suficiente e teve um burnout. Tente novamente.';
    wrapText(ctx, msg, W/2, iy + imgH + 16, panelW - 40, 22);

    // bot√£o
    const bw = 200, bh = 44;
    const bx = W/2 - bw/2;
    const by = py + panelH - bh - 20;
    ctx.fillStyle = '#1e1d1b';
    ctx.fillRect(bx, by, bw, bh);
    ctx.strokeStyle = '#5a5348';
    ctx.lineWidth = 2;
    ctx.strokeRect(bx, by, bw, bh);

    ctx.fillStyle = '#ffffff';
    ctx.font = '20px monospace';
    ctx.textBaseline = 'middle';
    ctx.fillText('Reiniciar', W/2, by + bh/2 + 2);

    // hitbox do bot√£o
    goBtn = { x: bx, y: by, w: bw, h: bh };
  }

  // Clique no canvas na tela de game over para reiniciar
  cvs.addEventListener('pointerdown', (e) => {
    if (!state.gameOver || !goBtn) return;
    const r = cvs.getBoundingClientRect();
    const x = (e.clientX - r.left) / r.width * W;
    const y = (e.clientY - r.top) / r.height * H;
    if (x >= goBtn.x && x <= goBtn.x + goBtn.w &&
        y >= goBtn.y && y <= goBtn.y + goBtn.h) {
        reset(); start();
    }
  });

  Promise.all(imageFiles.map(([name, file]) => loadImage(name, file))).then(() => {
    reset();
    draw();
    showMenu();
  });

})();
</script>
</body>
</html>
